---
phase: 09-cron-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/relay.ts
  - package.json
  - CLAUDE.md
autonomous: true

must_haves:
  truths:
    - "A cron job with a 5-field expression (e.g. 0 7 * * *) fires at the correct time"
    - "A one-shot job (e.g. in 20m) fires once after the specified delay and is auto-disabled"
    - "An interval job (e.g. every 2h) fires repeatedly at fixed intervals"
    - "Each cron execution spawns a Claude call with the job prompt and target thread context"
    - "Cron results are delivered to the correct Telegram thread or DM fallback"
  artifacts:
    - path: "src/relay.ts"
      provides: "Cron engine: schedule parsing, tick loop, execution, delivery, lifecycle"
      contains: "cronTick"
    - path: "package.json"
      provides: "croner dependency"
      contains: "croner"
    - path: "CLAUDE.md"
      provides: "Updated documentation for cron engine behavior"
      contains: "cronTick"
  key_links:
    - from: "cronTick()"
      to: "getEnabledCronJobs()"
      via: "Supabase query for enabled jobs"
      pattern: "getEnabledCronJobs"
    - from: "cronTick()"
      to: "Croner/computeNextRun"
      via: "Schedule parsing to determine due jobs"
      pattern: "isJobDue|computeNextRun"
    - from: "executeCronJob()"
      to: "callClaude()"
      via: "Claude CLI call with job prompt and thread context"
      pattern: "callClaude.*job\\.prompt|callClaude.*prompt"
    - from: "executeCronJob()"
      to: "sendCronResultToTelegram()"
      via: "Delivery to target thread or DM"
      pattern: "sendCronResult"
    - from: "bot.start onStart"
      to: "startCronScheduler()"
      via: "Lifecycle integration on boot"
      pattern: "startCronScheduler"
    - from: "SIGINT/SIGTERM"
      to: "stopCronScheduler()"
      via: "Clean shutdown"
      pattern: "stopCronScheduler"
---

<objective>
Build the cron engine: a tick-based scheduler that polls enabled cron jobs from Supabase, determines which are due based on their schedule type (cron expression, interval, one-shot), executes them via Claude CLI calls, and delivers results to the correct Telegram thread.

Purpose: This is the core execution engine for scheduled tasks. Without it, cron jobs stored in the database have no way to run.

Output: Working cron scheduler integrated into relay.ts lifecycle with schedule parsing, execution, and delivery for all three schedule types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-heartbeat-core/07-heartbeat-core-SUMMARY.md
@src/relay.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install croner and add cron schedule parsing + tick loop + execution + delivery</name>
  <files>src/relay.ts, package.json</files>
  <action>
**Step 1: Install croner library**

Run `bun add croner` to add the cron expression parsing library.

**Step 2: Add cron engine code to relay.ts**

Add `import { Cron } from "croner"` at the top with other imports.

Add the following functions AFTER the existing `disableCronJob()` function (around line 543) and BEFORE the heartbeat section. Use a new section comment: `// ============================================================ // CRON SCHEDULER ENGINE (Phase 9) // ============================================================`

**Module-level state:**
```typescript
let cronTimer: Timer | null = null;
let cronRunning = false;
const CRON_TICK_INTERVAL_MS = 60 * 1000; // Check every 60 seconds
```

**Function: `computeNextRun(job: CronJob): string | null`**
Computes the next run timestamp based on schedule_type:
- `cron`: Use `new Cron(job.schedule).nextRun()?.toISOString()` — croner parses 5-field expressions natively. If schedule is invalid, log error and return null.
- `interval`: Parse schedule string like "every 2h", "every 30m", "every 1h30m". Extract hours/minutes from the pattern `every\s+(?:(\d+)h)?(?:(\d+)m)?`. Compute next_run_at as `last_run_at + interval` (or `now + interval` if never ran). Return ISO string.
- `once`: Parse schedule string like "in 20m", "in 1h", "in 2h30m". Extract hours/minutes from pattern `in\s+(?:(\d+)h)?(?:(\d+)m)?`. Compute next_run_at as `created_at + delay`. Return ISO string. If the computed time is in the past and job has never run, it means the job is due NOW — return current time ISO.

**Function: `isJobDue(job: CronJob): boolean`**
Returns true if the job should execute now:
- If `job.next_run_at` is set and `new Date(job.next_run_at) <= new Date()`, return true.
- If `job.next_run_at` is null (never computed), compute it via `computeNextRun()`, and if the result is `<= now`, return true. (This handles newly created jobs.)

**Function: `getThreadInfoForCronJob(job: CronJob): Promise<ThreadInfo | undefined>`**
Resolves a cron job's `target_thread_id` (UUID from threads table) into a ThreadInfo for Claude context:
- If `job.target_thread_id` is null, return undefined (standalone call, no thread context).
- Query Supabase: `supabase.from("threads").select("*").eq("id", job.target_thread_id).single()`.
- If found, construct a ThreadInfo object: `{ dbId: data.id, chatId: data.telegram_chat_id, threadId: data.telegram_thread_id, title: data.title, sessionId: data.claude_session_id, summary: data.summary || "", messageCount: data.message_count || 0 }`.
- If not found, return undefined (thread was deleted).

**Function: `sendCronResultToTelegram(message: string, job: CronJob, threadInfo?: ThreadInfo): Promise<void>`**
Delivers cron execution result to the correct Telegram destination:
- Determine chatId and threadId:
  - If `threadInfo` exists: use `threadInfo.chatId` and `threadInfo.threadId`.
  - Otherwise: use `parseInt(ALLOWED_USER_ID)` (DM fallback), no threadId.
- Convert markdown to HTML using existing `markdownToTelegramHtml()`.
- Send via `bot.api.sendMessage(chatId, html, { parse_mode: "HTML", message_thread_id: threadId })`.
- On HTML parse error: retry without parse_mode (strip tags).
- Handle chunking for long messages (same pattern as `sendHeartbeatToTelegram()` with 4000 char limit).
- Prefix the message with a brief header: `<b>[Cron: ${job.name}]</b>\n\n` so the user knows which job produced the output.

**Function: `async function executeCronJob(job: CronJob): Promise<void>`**
Executes a single cron job:
1. Log event: `await logEventV2("cron_executed", "Cron job fired: " + job.name, { job_id: job.id, job_name: job.name, schedule: job.schedule, schedule_type: job.schedule_type })`.
2. Resolve thread: `const threadInfo = await getThreadInfoForCronJob(job)`.
3. Build prompt: Include soul + global memory + the job's prompt + current time. Use a helper similar to heartbeat but simpler: `const soul = await getActiveSoul(); const globalMemory = await getGlobalMemory(); let prompt = soul + "\n\nCurrent time: " + new Date().toLocaleString(...) + "\n\n"; if (globalMemory.length > 0) { prompt += "THINGS I KNOW ABOUT THE USER:\n" + globalMemory.map(m => "- " + m).join("\n") + "\n\n"; } prompt += "SCHEDULED TASK:\n" + job.prompt;`
4. Call Claude: `const { text, sessionId } = await callClaude(prompt, threadInfo)`.
5. If threadInfo and sessionId, update thread session: `await updateThreadSession(threadInfo.dbId, sessionId)`.
6. If response is empty or error, log `cron_error` and return.
7. Process intents: `const cleanResponse = await processIntents(text, threadInfo?.dbId)`.
8. Strip voice tags: `cleanResponse.replace(/\[VOICE_REPLY\]/gi, "").trim()`.
9. Deliver: `await sendCronResultToTelegram(finalMessage, job, threadInfo)`.
10. Compute next run: `const nextRun = computeNextRun(job)`.
11. Update last_run_at: `await updateCronJobLastRun(job.id, nextRun || undefined)`.
12. For one-shot jobs: `if (job.schedule_type === "once") { await disableCronJob(job.id); }`.
13. Log success: `await logEventV2("cron_delivered", "Cron result delivered: " + job.name, { job_id: job.id, message_length: finalMessage.length })`.

**Function: `async function cronTick(): Promise<void>`**
The main tick loop (runs every 60 seconds):
1. If `cronRunning` is true, skip (guard against overlapping ticks).
2. Set `cronRunning = true` in try/finally.
3. Fetch all enabled jobs: `const jobs = await getEnabledCronJobs()`.
4. If no jobs, return early.
5. For each job, check if due:
   - If `job.next_run_at` is null, compute and update it in DB: `const nextRun = computeNextRun(job); if (nextRun) await updateCronJobLastRun(job.id, nextRun);` then check if it's already due.
   - If `isJobDue(job)` is true, execute: `await executeCronJob(job)`.
6. Process jobs sequentially (not in parallel) to avoid overwhelming Claude CLI. One job at a time.
7. Catch errors per-job: wrap executeCronJob in try/catch, log `cron_error` with job_id and error message, continue to next job.
8. Finally block sets `cronRunning = false`.

**Function: `startCronScheduler(): void`**
```typescript
function startCronScheduler(): void {
  if (cronTimer) clearInterval(cronTimer);
  cronTimer = setInterval(cronTick, CRON_TICK_INTERVAL_MS);
  console.log("Cron scheduler: started (checking every 60s)");
}
```

**Function: `stopCronScheduler(): void`**
```typescript
function stopCronScheduler(): void {
  if (cronTimer) {
    clearInterval(cronTimer);
    cronTimer = null;
    console.log("Cron scheduler: stopped");
  }
}
```

**Step 3: Integrate into lifecycle**

1. In the `bot.start({ onStart: ... })` callback (around line 1756), after the heartbeat start block, add:
```typescript
// Start cron scheduler
startCronScheduler();
```

2. In both SIGINT and SIGTERM handlers (around lines 1059-1069), add `stopCronScheduler()` right after `stopHeartbeat()`:
```typescript
process.on("SIGINT", async () => {
  stopHeartbeat();
  stopCronScheduler();
  ...
});
process.on("SIGTERM", async () => {
  stopHeartbeat();
  stopCronScheduler();
  ...
});
```

**Important implementation notes:**
- croner library is used ONLY for `schedule_type: 'cron'`. Interval and one-shot parsing is manual regex.
- The cronTick interval is 60 seconds (independent of heartbeat interval). This means jobs are accurate to within ~1 minute.
- Jobs execute sequentially within a single tick to prevent concurrent Claude CLI calls from the cron system.
- The `cronRunning` guard prevents tick N+1 from starting while tick N is still executing long-running jobs.
- Intent processing ([LEARN:], [FORGET:]) works in cron context, same as heartbeat.
- One-shot jobs are disabled AFTER successful execution, not before (so they retry on failure).
  </action>
  <verify>
1. `bun run build` or `bun run start` does not crash (syntax check)
2. `import { Cron } from "croner"` resolves (croner is in package.json and node_modules)
3. grep for `cronTick` in relay.ts returns the function
4. grep for `startCronScheduler` in relay.ts returns the function AND its call in onStart
5. grep for `stopCronScheduler` in relay.ts returns the function AND its calls in SIGINT/SIGTERM
6. grep for `executeCronJob` in relay.ts returns the function
7. grep for `sendCronResultToTelegram` in relay.ts returns the function
8. grep for `computeNextRun` in relay.ts returns the function with all 3 schedule_type cases
9. grep for `isJobDue` in relay.ts returns the function
  </verify>
  <done>
All three schedule types (cron, interval, once) are parsed and their next_run_at computed. The tick loop polls every 60s, identifies due jobs, executes them via Claude CLI (with thread context if target_thread_id is set), delivers results to the correct Telegram thread or DM, updates last_run_at/next_run_at, and auto-disables one-shot jobs. Cron scheduler starts on boot and stops on shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CLAUDE.md with cron engine documentation</name>
  <files>CLAUDE.md</files>
  <action>
Update CLAUDE.md to document the cron engine behavior added in Task 1.

**Change 1:** In the "Architecture" section, find the `**Heartbeat & cron events**` bullet and update to include new cron event types:

Find:
```
- **Heartbeat & cron events** — Logged to `logs_v2` with event types: `heartbeat_tick`, `heartbeat_ok`, `heartbeat_delivered`, `heartbeat_dedup`, `heartbeat_skip`, `heartbeat_error`, `cron_executed`, `cron_error`, `bot_stopping`
```

Replace with:
```
- **Heartbeat & cron events** — Logged to `logs_v2` with event types: `heartbeat_tick`, `heartbeat_ok`, `heartbeat_delivered`, `heartbeat_dedup`, `heartbeat_skip`, `heartbeat_error`, `cron_executed`, `cron_delivered`, `cron_error`, `bot_stopping`
```

**Change 2:** In the "Architecture" section, after the `**Heartbeat timer**` bullet, add a new bullet for the cron scheduler:

```
- **Cron scheduler** — `cronTick()` fires every 60s, polls `cron_jobs` table for enabled jobs, checks `next_run_at` to determine due jobs. Supports three schedule types: `cron` (5-field via croner library), `interval` (e.g. "every 2h"), `once` (e.g. "in 20m"). Each execution spawns a Claude call with job prompt and thread context, delivers result to target thread or DM. One-shot jobs auto-disable after execution. Starts on boot via `onStart`, stops on SIGINT/SIGTERM.
```

**Change 3:** In the "Dependencies" section, add croner:

After the `**ffmpeg**` line, add:
```
- **croner** ^9+ — Cron expression parser for 5-field cron schedules with timezone support
```

**Change 4:** In the "Key sections in relay.ts" area, add a bullet for cron:

After the heartbeat-related bullets, add:
```
- **Cron scheduler engine** — `cronTick()`, `executeCronJob()`, `sendCronResultToTelegram()`, `computeNextRun()`, `isJobDue()`, `getThreadInfoForCronJob()`, `startCronScheduler()`, `stopCronScheduler()`
```
  </action>
  <verify>
1. grep for "Cron scheduler" in CLAUDE.md returns the new architecture bullet
2. grep for "croner" in CLAUDE.md returns the new dependency entry
3. grep for "cron_delivered" in CLAUDE.md confirms updated event types
4. grep for "cronTick" in CLAUDE.md returns the cron scheduler engine bullet
  </verify>
  <done>
CLAUDE.md accurately documents the cron engine: schedule types, tick interval, execution flow, delivery routing, lifecycle integration, croner dependency, and all cron event types.
  </done>
</task>

</tasks>

<verification>
1. `bun run start` boots without errors, prints "Cron scheduler: started (checking every 60s)" in console
2. All functions exist: cronTick, executeCronJob, sendCronResultToTelegram, computeNextRun, isJobDue, getThreadInfoForCronJob, startCronScheduler, stopCronScheduler
3. croner is listed in package.json dependencies
4. Lifecycle: startCronScheduler() is called in onStart, stopCronScheduler() is called in both SIGINT and SIGTERM handlers
5. CLAUDE.md documents cron engine behavior, croner dependency, and event types
</verification>

<success_criteria>
- Cron jobs with 5-field expressions execute at correct times (within 60s accuracy)
- One-shot timer jobs fire once and auto-disable
- Interval jobs fire repeatedly at fixed intervals
- Each execution spawns Claude call with appropriate thread context
- Results delivered to correct Telegram thread or DM fallback
- Cron scheduler starts on boot and stops cleanly on shutdown
- No interference with heartbeat system
</success_criteria>

<output>
After completion, create `.planning/phases/09-cron-engine/09-cron-engine-SUMMARY.md`
</output>
